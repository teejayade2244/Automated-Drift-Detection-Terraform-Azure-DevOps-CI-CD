trigger: none

schedules:
- cron: "0 9 * * *"
  displayName: Daily Terraform Drift Detection
  branches:
    include:
    - master
  always: true

variables:
  - group: SlackSecrets  
  - name: terraformVersion
    value: '1.5.0'
  - name: workingDirectory
    value: '$(System.DefaultWorkingDirectory)/terraform'
  - name: azureServiceConnection
    value: 'Azure-Resource-Manager' 
  - name: tfBackendResourceGroup
    value: 'Temitope'
  - name: tfBackendStorageAccount
    value: 'sttfstateorageacc'
  - name: tfBackendContainer
    value: 'tfstate'
  - name: tfBackendKey
    value: 'drift-detection.tfstate'

stages:
- stage: DriftDetection
  displayName: Terraform Drift Detection
  jobs:
  - job: DetectDrift
    displayName: Install, Init, Validate, & Plan
    pool:
      vmImage: 'Hosted Agent'
    
    steps:
    - checkout: self
      displayName: 'Checkout Repository'
    
    # 1. INSTALL TERRAFORM (Only needs to run once per job)
    - task: TerraformInstaller@1
      displayName: 'Install Terraform'
      inputs:
        terraformVersion: '$(terraformVersion)'
    
    # 2. INIT BACKEND (Only needs to run once per job)
    - task: TerraformTaskV4@4
      displayName: 'Terraform Init'
      inputs:
        provider: 'azurerm'
        command: 'init'
        workingDirectory: '$(workingDirectory)'
        backendServiceArm: '$(azureServiceConnection)'
        backendAzureRmResourceGroupName: '$(tfBackendResourceGroup)'
        backendAzureRmStorageAccountName: '$(tfBackendStorageAccount)'
        backendAzureRmContainerName: '$(tfBackendContainer)'
        backendAzureRmKey: '$(tfBackendKey)'

    # 3. VALIDATE CONFIGURATION
    - task: TerraformTaskV4@4
      displayName: 'Terraform Validate'
      inputs:
        provider: 'azurerm'
        command: 'validate'
        workingDirectory: '$(workingDirectory)'

    # 4. PLAN AND CAPTURE EXIT CODE
    - task: Bash@3
      displayName: 'Terraform Plan & Analyze Exit Code'
      inputs:
        targetType: 'filePath' 
        filePath: '$(workingDirectory)/drift_detection.sh' 
        workingDirectory: '$(workingDirectory)'
      name: AnalyzeExitCode
      env:
        ARM_CLIENT_ID: $(servicePrincipalId)
        ARM_CLIENT_SECRET: $(servicePrincipalKey)
        ARM_TENANT_ID: $(tenantId)
        ARM_SUBSCRIPTION_ID: $(subscriptionId)

    # 5. PUBLISH ARTIFACTS
    - task: PublishBuildArtifacts@1
      displayName: 'Publish Terraform Plan Artifact (tfplan)'
      condition: succeededOrFailed() 
      inputs:
        PathtoPublish: '$(workingDirectory)/tfplan'
        ArtifactName: 'terraform-drift-plan-$(Build.BuildId)'
        publishLocation: 'Container'

    - task: PublishBuildArtifacts@1
      displayName: 'Publish Drift Report (TXT)'
      condition: eq(variables['AnalyzeExitCode.planExitCode'], '2')
      inputs:
        PathtoPublish: '$(workingDirectory)/drift-report.txt'
        ArtifactName: 'drift-report-$(Build.BuildId)'
        publishLocation: 'Container'

- stage: Notify
  displayName: üí¨ Send Notifications
  dependsOn: DriftDetection
  condition: always() # Ensure notification runs regardless of drift detection outcome
  jobs:
  - job: SendSlackNotification
    displayName: Send Slack Alert
    pool:
      vmImage: 'Hosted Agent'
    
    variables:
      # Retrieve the plan exit code from the preceding stage/job
      planExitCode: $[ stageDependencies.DriftDetection.DetectDrift.outputs['AnalyzeExitCode.planExitCode'] ]
    
    steps:
    - task: Bash@3
      displayName: 'Generate & Send Slack Notification'
      inputs:
        targetType: 'inline'
        script: |
          PLAN_CODE="$(planExitCode)"
          echo "Terraform Plan Exit Code: $PLAN_CODE"
          
          PIPELINE_URL="$(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
          
          case "$PLAN_CODE" in
            0)
              MESSAGE="‚úÖ *Terraform Drift Check Passed*\n‚Ä¢ No infrastructure drift detected"
              COLOR="good"
              EMOJI=":white_check_mark:"
              ;;
            2)
              MESSAGE="‚ö†Ô∏è *Terraform Drift Detected!*\n‚Ä¢ Infrastructure changes found. Review the plan artifact."
              COLOR="warning"
              EMOJI=":warning:"
              ;;
            1)
              MESSAGE="‚ùå *Terraform Drift Check Failed*\n‚Ä¢ Terraform plan encountered errors. Review pipeline logs."
              COLOR="danger"
              EMOJI=":x:"
              ;;
            *)
              MESSAGE="‚ùì *Terraform Drift Check - Unknown Status*\n‚Ä¢ Exit Code: \`$PLAN_CODE\`"
              COLOR="#808080"
              EMOJI=":question:"
              ;;
          esac
          
          # Append common details
          MESSAGE="$MESSAGE\n‚Ä¢ Build: \`$(Build.BuildNumber)\`\n‚Ä¢ Branch: \`$(Build.SourceBranchName)\`\n‚Ä¢ Time: \`$(date -u +"%Y-%m-%d %H:%M:%S UTC")\`\n‚Ä¢ <$PIPELINE_URL|View Pipeline Details>"
          
          # Send to Slack using the webhook URL from the variable group
          curl -X POST -H 'Content-type: application/json' \
            --data "{
              \"attachments\": [{
                \"color\": \"$COLOR\",
                \"text\": \"$MESSAGE\",
                \"footer\": \"Azure DevOps - Terraform Drift Detection\",
                \"ts\": $(date +%s)
              }],
              \"icon_emoji\": \"$EMOJI\",
              \"username\": \"Terraform Drift Bot\"
            }" \
            "$(SLACK_WEBHOOK_URL)"
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Slack notification sent successfully"
          else
            echo "‚ùå Failed to send Slack notification"
            # Do not fail the notification job if Slack fails, unless critical
            exit 0
          fi